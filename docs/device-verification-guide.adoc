= Device Security Verification Guide
:toc:
:toc-title: Table of Contents
:toclevels: 3

This document provides comprehensive procedures to verify that provisioned Raspberry Pi devices have the correct security configuration, including secure boot enforcement, firmware versions, device-specific encryption keys, and JTAG restrictions.

== Overview

This verification guide covers five critical security aspects:

1. **Secure Boot Enforcement**: Verify secure boot is active using your customer signing key
2. **Firmware Version**: Confirm the correct firmware version is running
3. **Device-Specific Encryption Key**: Verify a unique encryption key was written to OTP
4. **Encryption Key Usage**: Confirm the device-specific key is being used for OS decryption
5. **JTAG Status**: Verify JTAG debugging is disabled

== Prerequisites

=== Required Access

* **Provisioning System Access**: Access to the rpi-sb-provisioner system used for device provisioning
* **Device Physical Access**: Physical access to the provisioned Raspberry Pi device for on-device verification
* **Network Access**: Network connectivity to the provisioning system's web interface (port 3142)

=== Required Information

Before beginning verification, gather the following information from your provisioning configuration:

* **Device Serial Number**: The unique serial number of the device to verify
* **Customer Key File Path**: Path to your `CUSTOMER_KEY_FILE_PEM` used during provisioning
* **Expected Firmware File**: Path to `RPI_DEVICE_FIRMWARE_FILE` if specified
* **Manufacturing Database Path**: Location of `RPI_SB_PROVISIONER_MANUFACTURING_DB`

== Verification Procedures

=== 1. Secure Boot Enforcement Verification

==== 1.1 Check Manufacturing Database

Verify the device was provisioned with secure boot enabled:

[source,bash]
----
# Query the manufacturing database for secure boot status
sqlite3 ${RPI_SB_PROVISIONER_MANUFACTURING_DB} \
  "SELECT serial, secure, provision_ts FROM devices WHERE serial = '<device_serial>';"
----

**Expected Result**: The `secure` field should be `1` indicating secure boot was enabled during provisioning.

==== 1.2 Verify Customer Key Hash in Provisioning Records

Check that your customer signing key was used:

[source,bash]
----
# Access provisioning logs for the device
ls -la /var/log/rpi-sb-provisioner/<device_serial>/

# Check bootstrap logs for key programming
grep -i "program_pubkey\|Writing key" /var/log/rpi-sb-provisioner/<device_serial>/bootstrap.log
----

**Expected Result**: Logs should show `program_pubkey=1` was set and key writing operations completed successfully.

==== 1.3 On-Device OTP Verification

On the provisioned device, verify the OTP key has been programmed:

[source,bash]
----
# Check OTP register 30 for customer public key hash (on device)
vcgencmd otp_dump | grep "30:"

# Check firmware version
vcgencmd version
----

**Expected Result**: OTP register 30 should contain a non-zero value (your customer key hash), and `vcgencmd version` should show the current firmware version being used.

==== 1.4 Customer Signing Key Hash Verification

Verify the customer signing key hash stored in OTP using rpiboot metadata fetch:

[source,bash]
----
# Use rpiboot to fetch device metadata and verify customer signing key
# This method is more reliable than manually parsing OTP registers

# First, calculate the expected hash from your customer signing key
echo "Calculating expected customer key hash..."
EXPECTED_HASH=$(openssl rsa -in ${CUSTOMER_KEY_FILE_PEM} -pubout -outform DER | sha256sum | awk '{print $1}')
echo "Expected hash: $EXPECTED_HASH"

# Put the device into rpiboot mode
echo ""
echo "Put the device into rpiboot mode:"
echo "- For CM4/CM5: Fit the EMMC-DISABLE/nRPIBOOT jumper"
echo "- For Pi5: Hold power button, then connect USB-C cable"
echo "- For Pi4: Short appropriate GPIO or use special boot mode"

# WARNING for Pi5 family devices
echo ""
echo "⚠️  WARNING: For Raspberry Pi 5-family devices (Pi5, CM5):"
echo "   You must sign the recovery.bin with your customer key before using rpiboot"
echo "   Unsigned recovery.bin will be rejected by secure boot enabled devices"
echo ""
echo "   To sign recovery.bin:"
echo "   cd /path/to/usbboot/recovery5"
echo "   ../tools/rpi-eeprom-digest -i recovery.bin -o recovery.sig -k ${CUSTOMER_KEY_FILE_PEM}"

read -p "Press Enter when device is in rpiboot mode and ready..."

# Use rpiboot to fetch device metadata
echo "Fetching device metadata..."
if ! command -v rpiboot &> /dev/null; then
    echo "✗ rpiboot not found. Please install usbboot tools:"
    echo "  git clone https://github.com/raspberrypi/usbboot"
    echo "  cd usbboot && make && sudo make install"
    exit 1
fi

# Use rpiboot with metadata flag to extract OTP information
# Note: recovery_metadata=1 must be set in recovery/config.txt
echo "Setting up recovery environment for metadata extraction..."

# Ensure we're in the usbboot directory and recovery subdirectory exists
if [ ! -d "recovery" ]; then
    echo "✗ recovery directory not found. Ensure you're in the usbboot repository directory"
    echo "  cd /path/to/usbboot"
    exit 1
fi

# Create metadata directory and enable metadata extraction
mkdir -p recovery/metadata
echo "recovery_metadata=1" >> recovery/config.txt  # Ensure metadata extraction is enabled

echo "Running rpiboot to extract metadata..."
if ! sudo rpiboot -j recovery/metadata -d recovery; then
    echo "✗ Failed to run rpiboot for metadata extraction"
    echo "  Ensure device is properly connected and in rpiboot mode"
    exit 1
fi

# Find the generated metadata JSON file
METADATA_FILE=$(ls recovery/metadata/*.json 2>/dev/null | head -1)
if [ ! -f "$METADATA_FILE" ]; then
    echo "✗ No metadata JSON file found in metadata/ directory"
    echo "  Ensure recovery_metadata=1 is set in recovery/config.txt"
    exit 1
fi

echo "Device metadata retrieved: $METADATA_FILE"

# Extract the customer key hash from the JSON metadata
DEVICE_KEY_HASH=$(jq -r '.CUSTOMER_KEY_HASH // empty' "$METADATA_FILE")

if [ -z "$DEVICE_KEY_HASH" ] || [ "$DEVICE_KEY_HASH" = "null" ]; then
    echo "✗ No customer signing key hash found in device metadata"
    echo "  Device may not have secure boot enabled"
    exit 1
fi

# Display metadata file contents for reference
echo "Complete device metadata:"
cat "$METADATA_FILE" | jq '.'

echo ""
echo "Customer key hash comparison:"
echo "Expected: $EXPECTED_HASH"
echo "Device:   $DEVICE_KEY_HASH"

# Compare the hashes
if [ "$EXPECTED_HASH" = "$DEVICE_KEY_HASH" ]; then
    echo "✓ Customer signing key hash matches perfectly!"
    echo "  Device was provisioned with the correct customer signing key"
elif [ "${EXPECTED_HASH:0:8}" = "${DEVICE_KEY_HASH:0:8}" ]; then
    echo "✓ Customer signing key hash matches (partial comparison)"
    echo "  Device uses a truncated version of your customer key hash"
else
    echo "✗ Customer signing key hash mismatch!"
    echo "  Expected: $EXPECTED_HASH"
    echo "  Device:   $DEVICE_KEY_HASH"
    echo "  Device may have been provisioned with a different signing key"
    exit 1
fi

# Display additional security information from metadata
echo ""
echo "Additional device security information:"
JTAG_LOCKED=$(jq -r '.JTAG_LOCKED // "unknown"' "$METADATA_FILE")
if [ "$JTAG_LOCKED" = "1" ]; then
    echo "✓ JTAG debugging is locked/disabled"
elif [ "$JTAG_LOCKED" = "0" ]; then
    echo "⚠ JTAG debugging is enabled (not locked)"
else
    echo "? JTAG lock status unknown"
fi

MAC_ADDR=$(jq -r '.MAC_ADDR // "unknown"' "$METADATA_FILE")
USER_BOARDREV=$(jq -r '.USER_BOARDREV // "unknown"' "$METADATA_FILE")
echo "  Device MAC: $MAC_ADDR"
echo "  Board revision: $USER_BOARDREV"

# Additional verification from provisioning logs
if grep -q "program_pubkey=1" "/var/log/rpi-sb-provisioner/<device_serial>/bootstrap.log" 2>/dev/null; then
    echo "✓ Provisioning logs confirm customer key was programmed to OTP"
else
    echo "⚠ Could not verify from provisioning logs (may be on different system)"
fi
----

**Expected Result**: The `CUSTOMER_KEY_HASH` field in the metadata JSON should match the SHA256 hash calculated from your `CUSTOMER_KEY_FILE_PEM`. The metadata will also show additional security information like JTAG lock status, device MAC address, and board revision. This definitively confirms that secure boot is enforced using your specific customer signing key.

=== 2. Firmware Version Verification

==== 2.1 Check Provisioning Configuration

Verify the firmware version used during provisioning:

[source,bash]
----
# Check the configuration file for firmware specification
grep "RPI_DEVICE_FIRMWARE_FILE" /etc/rpi-sb-provisioner/config

# If specified, verify the file exists and note its version
ls -la $(grep "RPI_DEVICE_FIRMWARE_FILE" /etc/rpi-sb-provisioner/config | cut -d'=' -f2)
----

==== 2.2 On-Device Firmware Verification

On the provisioned device, check the running firmware version:

[source,bash]
----
# Check firmware version (on device)
vcgencmd version

# Check bootloader configuration
vcgencmd bootloader_config

# Alternative: Check via dmesg
dmesg | grep -i bootloader
----

**Expected Result**: The firmware version should match the version specified in `RPI_DEVICE_FIRMWARE_FILE`, or if not specified, should be the latest version from the default release channel at the time of provisioning.

=== 3. Device-Specific Encryption Key Verification

==== 3.1 Verify Key Generation

Confirm device-unique keys were generated during provisioning:

[source,bash]
----
# Check if device-specific keypair exists
ls -la /var/log/rpi-sb-provisioner/<device_serial>/keypair/

# Verify both private and public keys exist
ls -la /var/log/rpi-sb-provisioner/<device_serial>/keypair/<device_serial>.*
----

**Expected Result**: Both `<device_serial>.der` (private key) and `<device_serial>.pub` (public key) files should exist.

==== 3.2 Key Uniqueness Verification

Verify the device key is unique by comparing with other devices:

[source,bash]
----
# Compare device key with another device (should be different)
sha256sum /var/log/rpi-sb-provisioner/<device_serial_1>/keypair/<device_serial_1>.pub
sha256sum /var/log/rpi-sb-provisioner/<device_serial_2>/keypair/<device_serial_2>.pub
----

**Expected Result**: Each device should have a unique key pair with different SHA256 hashes.

==== 3.3 API-Based Key Verification

Use the provisioning system API to verify key accessibility:

[source,bash]
----
# Retrieve device public key via API
curl -s http://localhost:3142/devices/<device_serial>/key/public > /tmp/api_public_key

# Compare with stored key
diff /tmp/api_public_key /var/log/rpi-sb-provisioner/<device_serial>/keypair/<device_serial>.pub
----

**Expected Result**: The API should return the same public key as stored in the keypair directory.

=== 4. Encryption Key Usage Verification

==== 4.1 Verify LUKSv2 Container Creation

Check that the device storage was properly encrypted during provisioning:

[source,bash]
----
# Check provisioning logs for encryption setup
grep -i "cryptinit\|luks\|crypt" /var/log/rpi-sb-provisioner/<device_serial>/provisioner.log

# Look for encryption cipher configuration
grep -i "RPI_DEVICE_STORAGE_CIPHER" /var/log/rpi-sb-provisioner/<device_serial>/provisioner.log
----

**Expected Result**: Logs should show successful `cryptinit` operations and the configured cipher (default: `aes-xts-plain64`).

==== 4.2 On-Device Encryption Verification

On the provisioned device, verify the encryption is active:

[source,bash]
----
# Check for encrypted root filesystem (on device)
lsblk -f

# Check LUKS status
cryptsetup status cryptroot

# Verify device-specific key usage in initramfs
# (This requires access to the initramfs which contains the device key)
lsinitramfs /boot/initramfs8 | grep -i key
----

**Expected Result**: 
- `lsblk -f` should show a crypto_LUKS filesystem type
- `cryptsetup status` should show an active mapping named "cryptroot"
- The device should boot successfully using its unique encryption key

==== 4.3 Boot Process Verification

Verify the device can only boot with its specific encryption key:

[source,bash]
----
# Check boot logs for successful decryption (on device)
journalctl -b | grep -i crypt

# Verify pre-boot authentication system worked (if you can run these commands, it succeeded)
# Check that encrypted root is mounted and active
cryptsetup status cryptroot

# Verify the device booted from encrypted storage  
findmnt / | grep -i crypt

# Look for crypto-related messages during current boot to confirm decryption occurred
journalctl -b | grep -E "(crypt|luks|initramfs.*completed)"
----

**Expected Result**: Boot logs should show successful cryptographic operations and pre-boot authentication completing successfully.

=== 5. JTAG Status Verification

==== 5.1 Check JTAG Configuration

Verify JTAG locking was configured during provisioning:

[source,bash]
----
# Check if JTAG locking was enabled in configuration
grep "RPI_DEVICE_LOCK_JTAG" /etc/rpi-sb-provisioner/config

# Check provisioning logs for JTAG lock operation
grep -i "jtag\|program_jtag_lock" /var/log/rpi-sb-provisioner/<device_serial>/bootstrap.log
----

**Expected Result**: If JTAG locking was configured, logs should show `program_jtag_lock=1` was set during the bootstrap process.

==== 5.2 Manufacturing Database JTAG Status

Query the manufacturing database for JTAG lock status:

[source,bash]
----
# Check raw security flags for specific device
sqlite3 ${RPI_SB_PROVISIONER_MANUFACTURING_DB} \
  "SELECT serial, jtag_locked, eeprom_write_protected, pubkey_programmed, signed_boot_enabled 
   FROM devices WHERE serial = '<device_serial>';"

# Human-readable security status summary for all devices
sqlite3 ${RPI_SB_PROVISIONER_MANUFACTURING_DB} \
  "SELECT serial, 
          CASE jtag_locked 
            WHEN 1 THEN 'LOCKED' 
            WHEN 0 THEN 'UNLOCKED' 
            ELSE 'UNKNOWN' 
          END as jtag_status,
          CASE eeprom_write_protected 
            WHEN 1 THEN 'PROTECTED' 
            WHEN 0 THEN 'UNPROTECTED' 
            ELSE 'UNKNOWN' 
          END as eeprom_status
   FROM devices ORDER BY provision_ts DESC;"
----

**Expected Results**: 
- **Raw values**: `jtag_locked=1` (enabled), `jtag_locked=0` (disabled), `jtag_locked=` (NULL/unknown)
- **Human-readable**: `jtag_status=LOCKED`, `jtag_status=UNLOCKED`, `jtag_status=UNKNOWN`
- Similar patterns apply to other security flags (`eeprom_write_protected`, `pubkey_programmed`, `signed_boot_enabled`)

==== 5.3 On-Device JTAG Verification

On the provisioned device, verify JTAG access is restricted:

[source,sh]
----
# Check OTP for JTAG lock status (on device)
# JTAG lock location varies by device family:
# - BCM2712 (Pi 5 family): Row 21, bits 26-27 
# - BCM2711 (Pi 4 family): Row 16, bits 26-27
# Bit pattern for JTAG lock: (3<<26) = 0x0C000000

# Detect device family from board revision
BOARD_REVISION=$(cat /proc/cpuinfo | grep "Revision" | cut -d: -f2 | tr -d ' ')
case "$BOARD_REVISION" in
    *17|*18|*19|*20) # Pi 5 family (BCM2712)
        JTAG_OTP_ROW="21"
        DEVICE_FAMILY="BCM2712 (Pi 5)"
        ;;
    *11|*14) # Pi 4 family (BCM2711) 
        JTAG_OTP_ROW="16"
        DEVICE_FAMILY="BCM2711 (Pi 4)"
        ;;
    *)
        echo "✗ ERROR: Unknown device family (revision: $BOARD_REVISION)"
        echo "  Cannot determine correct OTP row for JTAG lock verification"
        echo "  Supported devices: BCM2711 (Pi 4 family), BCM2712 (Pi 5 family)"
        echo "  Please consult Raspberry Pi documentation for this device family"
        exit 1
        ;;
esac

echo "Device family: $DEVICE_FAMILY"
echo "Checking JTAG lock in OTP row: $JTAG_OTP_ROW"

# Check JTAG lock status for detected device family
OTP_VALUE=$(vcgencmd otp_dump | grep "^${JTAG_OTP_ROW}:" | cut -d: -f2)
echo "OTP row ${JTAG_OTP_ROW}: 0x${OTP_VALUE}"

if [ -n "$OTP_VALUE" ] && [ $((0x$OTP_VALUE & 0x0C000000)) -eq $((0x0C000000)) ]; then
    echo "✓ JTAG lock bits are SET in row ${JTAG_OTP_ROW} (JTAG disabled)"
else
    echo "⚠ JTAG lock bits are NOT SET (JTAG may be enabled)"
fi

# Check bootloader configuration for JTAG settings
vcgencmd bootloader_config | grep -i jtag
----

**Expected Result**: 
- **BCM2712 (Pi 5)**: If JTAG locking was configured, OTP row 21 should have bits 26-27 set (pattern `0x0C000000`)
- **BCM2711 (Pi 4)**: If JTAG locking was configured, OTP row 16 should have bits 26-27 set (pattern `0x0C000000`)
- The verification script should detect device family and check the appropriate row
- If JTAG is locked, script should show "✓ JTAG lock bits are SET in row X (JTAG disabled)"

== Comprehensive Verification Script

=== Automated Verification Script

Create a comprehensive verification script to check all security aspects:

[source,sh]
----
#!/bin/sh
# Device Security Verification Script
# POSIX shell compatible

DEVICE_SERIAL="$1"
CUSTOMER_KEY_FILE="$2"
MANUFACTURING_DB="$3"

if [ -z "$DEVICE_SERIAL" ] || [ -z "$CUSTOMER_KEY_FILE" ] || [ -z "$MANUFACTURING_DB" ]; then
    echo "Usage: $0 <device_serial> <customer_key_file> <manufacturing_db>"
    exit 1
fi

echo "=== Device Security Verification Report ==="
echo "Device Serial: $DEVICE_SERIAL"
echo "Date: $(date)"
echo

# 1. Secure Boot Verification
echo "1. SECURE BOOT VERIFICATION"
SECURE_STATUS=$(sqlite3 "$MANUFACTURING_DB" "SELECT secure FROM devices WHERE serial = '$DEVICE_SERIAL';")
if [ "$SECURE_STATUS" = "1" ]; then
    echo "✓ Device marked as secure in manufacturing database"
else
    echo "✗ Device NOT marked as secure in manufacturing database"
fi

# Check provisioning logs
if grep -q "program_pubkey=1" "/var/log/rpi-sb-provisioner/$DEVICE_SERIAL/bootstrap.log" 2>/dev/null; then
    echo "✓ Customer public key programmed to OTP"
else
    echo "✗ No evidence of OTP key programming"
fi

# 2. Firmware Verification
echo
echo "2. FIRMWARE VERIFICATION"
if grep -q "RPI_DEVICE_FIRMWARE_FILE" /etc/rpi-sb-provisioner/config; then
    FIRMWARE_FILE=$(grep "RPI_DEVICE_FIRMWARE_FILE" /etc/rpi-sb-provisioner/config | cut -d'=' -f2)
    if [ -f "$FIRMWARE_FILE" ]; then
        echo "✓ Specific firmware file configured: $FIRMWARE_FILE"
    else
        echo "✗ Configured firmware file not found: $FIRMWARE_FILE"
    fi
else
    echo "✓ Using default firmware (latest from default channel)"
fi

# 3. Device Key Verification
echo
echo "3. DEVICE ENCRYPTION KEY VERIFICATION"
KEYPAIR_DIR="/var/log/rpi-sb-provisioner/$DEVICE_SERIAL/keypair"
if [ -f "$KEYPAIR_DIR/$DEVICE_SERIAL.der" ] && [ -f "$KEYPAIR_DIR/$DEVICE_SERIAL.pub" ]; then
    echo "✓ Device-specific keypair exists"
    echo "  Private key: $KEYPAIR_DIR/$DEVICE_SERIAL.der"
    echo "  Public key: $KEYPAIR_DIR/$DEVICE_SERIAL.pub"
else
    echo "✗ Device-specific keypair not found"
fi

# 4. Encryption Usage Verification
echo
echo "4. ENCRYPTION USAGE VERIFICATION"
if grep -q "cryptinit" "/var/log/rpi-sb-provisioner/$DEVICE_SERIAL/provisioner.log" 2>/dev/null; then
    echo "✓ Storage encryption initialized during provisioning"
else
    echo "✗ No evidence of storage encryption initialization"
fi

# 5. Security Lockdown Features Verification
echo
echo "5. SECURITY LOCKDOWN FEATURES VERIFICATION"

# Query all security flags from database
SECURITY_FLAGS=$(sqlite3 "$MANUFACTURING_DB" \
    "SELECT jtag_locked, eeprom_write_protected, pubkey_programmed, signed_boot_enabled 
     FROM devices WHERE serial = '$DEVICE_SERIAL';" 2>/dev/null || echo "|||")

# Parse the results (format: jtag_locked|eeprom_write_protected|pubkey_programmed|signed_boot_enabled)
JTAG_LOCKED=$(echo "$SECURITY_FLAGS" | cut -d'|' -f1)
EEPROM_WP=$(echo "$SECURITY_FLAGS" | cut -d'|' -f2)
PUBKEY_PROG=$(echo "$SECURITY_FLAGS" | cut -d'|' -f3)
SIGNED_BOOT=$(echo "$SECURITY_FLAGS" | cut -d'|' -f4)

# JTAG Lock Status
echo "  JTAG Lock Status:"
case "$JTAG_LOCKED" in
    "1") echo "    ✓ JTAG debugging is LOCKED (secure)" ;;
    "0") echo "    ⚠ JTAG debugging is UNLOCKED (device remains debuggable)" ;;
    *) echo "    ? JTAG lock status unknown (possibly older device)" ;;
esac

# EEPROM Write Protection Status  
echo "  EEPROM Write Protection:"
case "$EEPROM_WP" in
    "1") echo "    ✓ EEPROM write protection is ENABLED" ;;
    "0") echo "    ⚠ EEPROM write protection is DISABLED" ;;
    *) echo "    ? EEPROM write protection status unknown" ;;
esac

# Public Key Programming Status
echo "  Public Key Programming:"
case "$PUBKEY_PROG" in
    "1") echo "    ✓ Customer public key programmed to OTP" ;;
    "0") echo "    ⚠ Public key not programmed (non-secure provisioning)" ;;
    *) echo "    ? Public key programming status unknown" ;;
esac

# Signed Boot Status
echo "  Signed Boot:"
case "$SIGNED_BOOT" in
    "1") echo "    ✓ Signed boot is ENABLED" ;;
    "0") echo "    ⚠ Signed boot is DISABLED" ;;
    *) echo "    ? Signed boot status unknown" ;;
esac

echo
echo "=== End of Verification Report ==="
----

=== Running the Verification Script

[source,sh]
----
# Make the script executable
chmod +x device_verification.sh

# Run verification for a specific device
./device_verification.sh <device_serial> /path/to/customer_key.pem /path/to/manufacturing.db
----

== API-Based Verification

=== Using the Provisioning System API

The rpi-sb-provisioner provides REST APIs for programmatic verification:

==== Manufacturing Database Query

[source,bash]
----
# Get device information via API
curl -s "http://localhost:3142/api/v2/manufacturing" | jq '.[] | select(.serial == "<device_serial>")'

# Verify QR code (device serial) exists in database
curl -X POST http://localhost:3142/api/v2/verify-qrcode \
  -H "Content-Type: application/json" \
  -d '{"qrcode": "<device_serial>"}'
----

==== Device Status Check

[source,bash]
----
# Check current device status
curl -s "http://localhost:3142/devices/<device_serial>" | jq '.'

# Get device provisioning logs
curl -s "http://localhost:3142/devices/<device_serial>/log/provisioner"
----

== Troubleshooting Verification Issues

=== Common Issues and Solutions

==== Secure Boot Not Enabled

**Symptoms**: Manufacturing database shows `secure = 0`

**Possible Causes**:
- Device not provisioned with `secure-boot` style
- Customer key file missing or invalid during provisioning
- Device doesn't support secure boot (older models)

**Investigation**:
[source,bash]
----
# Check provisioning style used
grep "PROVISIONING_STYLE" /etc/rpi-sb-provisioner/config

# Check bootstrap logs for errors
grep -i error /var/log/rpi-sb-provisioner/<device_serial>/bootstrap.log
----

==== Missing Device Keys

**Symptoms**: Keypair directory empty or missing

**Possible Causes**:
- Provisioning failed before key generation
- Keys moved due to `RPI_DEVICE_RETRIEVE_KEYPAIR` configuration

**Investigation**:
[source,bash]
----
# Check if keys were moved to custom location
grep "RPI_DEVICE_RETRIEVE_KEYPAIR" /etc/rpi-sb-provisioner/config

# Check triage logs for key generation
grep -i keypair /var/log/rpi-sb-provisioner/<device_serial>/triage.log
----

==== Encryption Not Working

**Symptoms**: Device boots but storage not encrypted

**Possible Causes**:
- Provisioning style was `naked` (no encryption)
- Encryption initialization failed
- Wrong storage type configured

**Investigation**:
[source,bash]
----
# Check provisioning style
grep "PROVISIONING_STYLE" /etc/rpi-sb-provisioner/config

# Check storage type configuration
grep "RPI_DEVICE_STORAGE_TYPE" /etc/rpi-sb-provisioner/config

# Check provisioning logs
grep -i "crypt\|partition" /var/log/rpi-sb-provisioner/<device_serial>/provisioner.log
----

=== Log File Locations

Important log files for verification:

[source]
----
/var/log/rpi-sb-provisioner/<device_serial>/
├── bootstrap.log      # Bootstrap phase logs (OTP programming, firmware updates)
├── triage.log         # Triage phase logs (key generation)
├── provisioner.log    # Main provisioning logs (encryption, imaging)
└── keypair/           # Device-specific key storage
    ├── <serial>.der   # Private key
    └── <serial>.pub   # Public key
----

**IMPORTANT**: Device-specific log files are only created after the device enters the **triage stage**, which occurs after:

1. EEPROM firmware updates are completed
2. Security lockdown features (JTAG lock, EEPROM write protection) have been applied
3. The device has rebooted with the new firmware

This means that security lockdown verification logs (`bootstrap.log`) may not be immediately available during or immediately after the security configuration process. The manufacturing database provides immediate access to security status, while log files become available once the device progresses through the provisioning pipeline.

== Security Considerations

=== Key Management

* **Private Keys**: Device private keys should be securely stored and access-controlled
* **Customer Keys**: Your customer signing key (`CUSTOMER_KEY_FILE_PEM`) is critical security material
* **Database Security**: Manufacturing database contains sensitive device information

=== Verification Frequency

* **Initial Verification**: Perform complete verification immediately after provisioning
* **Periodic Audits**: Regular checks of manufacturing database for security compliance
* **Pre-Deployment**: Final verification before device deployment

=== Documentation Requirements

Maintain records of:

* Device serial numbers and their security status
* Firmware versions used for each device batch
* Verification results and any exceptions
* Key management procedures and access logs

== Conclusion

This verification guide provides comprehensive procedures to confirm that provisioned Raspberry Pi devices meet the specified security requirements. With the enhanced manufacturing database that now tracks security lockdown features, verification has become more reliable and automated.

Regular use of these verification steps ensures that:

1. **Secure boot is properly enforced** using your customer signing key
2. **The correct firmware version is running** on each device
3. **Device-specific encryption keys** are properly generated and stored
4. **Encryption keys are correctly used** for OS image decryption
5. **Security lockdown features are properly tracked**, including:
   - JTAG debugging restrictions
   - EEPROM write protection status
   - Public key programming confirmation
   - Signed boot enforcement