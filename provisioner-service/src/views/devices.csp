<!DOCTYPE html>
<html>
<head>
    <title>USB Topology</title>
    <%view stylesheet %>
    <script src="/static/js/d3.min.js"></script>
    <style>
        .topology-container { padding: 10px; }
        .node { border: 1px solid #ccc; border-radius: 6px; padding: 8px 10px; margin: 6px; background: #fafafa; display: inline-block; min-width: 160px; }
        .hub { background: #eef6ff; border-color: #9ec9ff; }
        .device { background: #f7fff0; border-color: #bde6a1; }
        .node .title { font-weight: bold; margin-bottom: 4px; }
        .children { margin-left: 24px; border-left: 2px dashed #ddd; padding-left: 12px; }
        .state-provisioning { box-shadow: 0 0 0 2px #ffd54f inset; }
        .state-success { box-shadow: 0 0 0 2px #4caf50 inset; }
        .state-error { box-shadow: 0 0 0 2px #f44336 inset; }
        .meta { color: #555; font-size: 12px; }
        .badge { display: inline-block; font-weight: 700; font-size: 14px; line-height: 1; padding: 2px 6px; border-radius: 10px; margin-left: 6px; }
        .badge-gen { color: #fff; background: #d32f2f; }
        .badge-empty { color: #fff; background: #9e9e9e; }
        /* Tabs and relational (mind map) view styling */
        .view-tabs { margin: 12px 0 8px; display: flex; gap: 8px; }
        .view-tab { border: 1px solid #9ec9ff; background: #eef6ff; color: #0b3d91; padding: 6px 10px; border-radius: 14px; font-weight: 600; cursor: pointer; }
        .view-tab.active { background: #0b69ff; color: #fff; border-color: #0b69ff; }
        .view-container { display: none; }
        .view-container.active { display: block; }
        .mindmap-container { padding: 4px; position: relative; background: #fafafa; border: 1px solid #ddd; border-radius: 4px; }
        .mindmap-container svg { width: 100%; height: 70vh; display: block; min-height: 500px; }
        
        /* D3 Graph Styles */
        .d3-link { stroke: #bbb; stroke-width: 2; fill: none; stroke-opacity: 0.6; }
        .d3-link.highlighted { stroke: #0b69ff; stroke-width: 3; stroke-opacity: 1; }
        
        .d3-node-circle { stroke-width: 2.5; cursor: pointer; transition: all 0.2s ease; }
        .d3-node-circle.hub { fill: #eef6ff; stroke: #9ec9ff; }
        .d3-node-circle.device { fill: #f7fff0; stroke: #bde6a1; }
        .d3-node-circle.server { fill: #fff; stroke: #666; stroke-width: 3; }
        .d3-node-circle:hover { stroke-width: 4; filter: brightness(1.1); }
        .d3-node-circle.clicked { stroke: #0b69ff; stroke-width: 4; filter: drop-shadow(0 0 8px rgba(11, 105, 255, 0.5)); }
        
        .d3-node-label { font: 12px sans-serif; text-anchor: middle; pointer-events: none; user-select: none; }
        .d3-node-badge { font: 10px sans-serif; font-weight: bold; fill: #fff; text-anchor: middle; pointer-events: none; }
        .d3-node-state { font: 10px sans-serif; fill: #555; text-anchor: middle; pointer-events: none; }
        
        .d3-watermark { font-family: sans-serif; font-weight: 900; opacity: 0.12; fill: #d32f2f; pointer-events: none; text-anchor: middle; dominant-baseline: middle; }
        
        /* Tooltip */
        .d3-tooltip { position: absolute; padding: 8px 12px; background: rgba(0, 0, 0, 0.85); color: #fff; border-radius: 4px; 
                      font-size: 12px; pointer-events: none; z-index: 1000; white-space: nowrap; opacity: 0; transition: opacity 0.2s; }
        .d3-tooltip.visible { opacity: 1; }
        
        /* Zoom controls */
        .zoom-controls { position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 4px; z-index: 100; }
        .zoom-btn { width: 32px; height: 32px; border: 1px solid #9ec9ff; background: #fff; color: #0b3d91; border-radius: 4px; 
                    cursor: pointer; font-weight: bold; font-size: 16px; display: flex; align-items: center; justify-content: center; 
                    transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .zoom-btn:hover { background: #eef6ff; transform: scale(1.1); }
        .zoom-btn:active { transform: scale(0.95); }
    </style>
    <script>
        let ws = null;
        const elementsById = new Map();
    
        function makeNodeElement(node) {
            const el = document.createElement('div');
            el.className = 'node ' + (node.isHub ? 'hub' : 'device');
            el.dataset.id = node.id;
            const title = document.createElement('div');
            title.className = 'title';
            const baseLabel = labelFor(node);
            title.textContent = baseLabel;
            const badge = document.createElement('span');
            const b = computeBadge(node);
            if (b) {
                badge.className = 'badge ' + b.className;
                badge.textContent = b.text;
                title.appendChild(badge);
            }
            const meta = document.createElement('div');
            meta.className = 'meta';
            meta.textContent = metaFor(node);
            const children = document.createElement('div');
            children.className = 'children';
            el.appendChild(title);
            el.appendChild(meta);
            el.appendChild(children);
            applyStateClass(el, node.state);
            return el;
        }
    
        // --- Topology normalization helpers (UI-only) ---
        function parseBusAndChain(id) {
            // Returns { bus: '1', chain: '1.2.3' } or null
            const m = String(id).match(/^(\d+)-([0-9]+(?:\.[0-9]+)*)$/);
            if (!m) return null;
            return { bus: m[1], chain: m[2] };
        }

        function parseRootPort(id) {
            // Returns numeric string for top-level root port (no dot), else null
            const m = String(id).match(/^(\d+)-([0-9]+)$/);
            return m ? m[2] : null;
        }

        function parseBus(id) {
            const m = String(id).match(/^(\d+)-/);
            return m ? parseInt(m[1], 10) : NaN;
        }

        function ensureRootPortGroup(portIdx) {
            const groupId = `rootport-${portIdx}`;
            if (elementsById.has(groupId)) return elementsById.get(groupId);
            const el = document.createElement('div');
            el.className = 'node hub';
            el.dataset.id = groupId;
            const title = document.createElement('div');
            title.className = 'title';
            title.textContent = `Root Port ${portIdx}`;
            const meta = document.createElement('div');
            meta.className = 'meta';
            meta.textContent = '';
            const children = document.createElement('div');
            children.className = 'children';
            el.appendChild(title);
            el.appendChild(meta);
            el.appendChild(children);
            const serverEl = ensureParentExists('server');
            serverEl.querySelector('.children').appendChild(el);
            elementsById.set(groupId, el);
            return el;
        }

        function ensureRootPortGroupUnder(rootEl, portIdx) {
            const tier = rootEl && rootEl.dataset && rootEl.dataset.id === 'usb3-root' ? 'ss' : 'hs';
            const groupId = `rootport-${tier}-${portIdx}`;
            if (elementsById.has(groupId)) return elementsById.get(groupId);
            const el = document.createElement('div');
            el.className = 'node hub';
            el.dataset.id = groupId;
            const title = document.createElement('div');
            title.className = 'title';
            title.textContent = `Root Port ${portIdx}`;
            const meta = document.createElement('div');
            meta.className = 'meta';
            meta.textContent = '';
            const children = document.createElement('div');
            children.className = 'children';
            el.appendChild(title);
            el.appendChild(meta);
            el.appendChild(children);
            rootEl.querySelector('.children').appendChild(el);
            elementsById.set(groupId, el);
            return el;
        }

        function ensureRootTier(tier) {
            const id = tier === 'ss' ? 'usb3-root' : 'usb2-root';
            if (elementsById.has(id)) return elementsById.get(id);
            const el = document.createElement('div');
            el.className = 'node hub';
            el.dataset.id = id;
            const title = document.createElement('div');
            title.className = 'title';
            title.textContent = tier === 'ss' ? 'USB 3 Root' : 'USB 2 Root';
            const meta = document.createElement('div');
            meta.className = 'meta';
            meta.textContent = '';
            const children = document.createElement('div');
            children.className = 'children';
            el.appendChild(title);
            el.appendChild(meta);
            el.appendChild(children);
            const serverEl = ensureParentExists('server');
            serverEl.querySelector('.children').appendChild(el);
            elementsById.set(id, el);
            return el;
        }

        function busTierForId(id) {
            const m = String(id).match(/^(\d+)-/);
            if (!m) return null;
            const bus = parseInt(m[1], 10);
            // On Pi 5, buses 3/4 are SuperSpeed; 1/2 are HighSpeed
            if (bus === 3 || bus === 4) return 'ss';
            if (bus === 1 || bus === 2) return 'hs';
            return null;
        }

        function buildCanonicalRootHubMap(nodes) {
            // Coalesce by root port. Prefer an SS roothub when present; if not, pick one HS roothub.
            const canonicalByPort = new Map(); // portIdx -> canonicalRootId like '4-1'
            const hsFallbackByPort = new Map(); // portIdx -> chosen HS root id
            for (const n of nodes) {
                if (!n || !n.isHub) continue;
                const pid = n.parentId ? String(n.parentId) : 'server';
                const rootPort = parseRootPort(String(n.id));
                if (pid !== 'server' || !rootPort) continue;
                const tier = busTierForId(String(n.id));
                const { bus } = parseBusAndChain(String(n.id)) || {};
                if (tier === 'ss') {
                    const current = canonicalByPort.get(rootPort);
                    if (!current) {
                        canonicalByPort.set(rootPort, String(n.id));
                    } else {
                        // Prefer higher SS bus number (e.g., 4 over 3)
                        const existingBus = parseInt(current.split('-')[0], 10);
                        const newBus = parseInt(bus, 10);
                        if (newBus > existingBus) canonicalByPort.set(rootPort, String(n.id));
                    }
                } else if (tier === 'hs') {
                    const currentHs = hsFallbackByPort.get(rootPort);
                    if (!currentHs) {
                        hsFallbackByPort.set(rootPort, String(n.id));
                    } else {
                        // Prefer lower HS bus number for stability
                        const existingBus = parseInt(currentHs.split('-')[0], 10);
                        const newBus = parseInt(bus, 10);
                        if (newBus < existingBus) hsFallbackByPort.set(rootPort, String(n.id));
                    }
                }
            }
            // Fill gaps with HS fallback when no SS canonical exists
            for (const [port, hsId] of hsFallbackByPort.entries()) {
                if (!canonicalByPort.has(port)) canonicalByPort.set(port, hsId);
            }
            return canonicalByPort;
        }

        function canonicalizeIdByRoot(id, canonicalByPort) {
            // Coalesce by root port: map any id starting with '<bus>-<port>'
            // to the canonical SuperSpeed root for that port when available.
            // This hides HS root placeholders and re-parents HS-only children
            // under the SS "Root Port n" group without losing visibility.
            const m = String(id).match(/^(\d+)-([0-9]+)(\..*)?$/);
            if (!m) return String(id);
            const port = m[2];
            const rest = m[3] || '';
            const canonicalRoot = canonicalByPort.get(port);
            if (!canonicalRoot) return String(id);
            const canonicalPrefix = canonicalRoot; // like '2-1'
            return canonicalPrefix + rest;
        }

        function applyStateClass(el, state) {
            el.classList.remove('state-provisioning', 'state-success', 'state-error');
            if (!state) return;
            const s = state.toLowerCase();
            if (s.includes('provision') || s.includes('pending')) el.classList.add('state-provisioning');
            else if (s.includes('success') || s.includes('complete')) el.classList.add('state-success');
            else if (s.includes('error') || s.includes('fail')) el.classList.add('state-error');
        }
    
        function labelFor(n) {
            if (n.id === 'server') return 'Provisioning Server';
            if (String(n.id).startsWith('rootport-')) {
                const parts = String(n.id).split('-');
                const idx = parts[parts.length - 1];
                return `Root Port ${idx}`;
            }
            const idStr = String(n.id);
            // Annotate hubs to avoid confusing vendor/serial strings
            if (n.isHub) {
                if (n.serial) return `${n.serial} (USB Hub)`;
                if (n.vendor || n.product) return `${n.vendor || ''}:${n.product || ''} (USB Hub) (${idStr})`;
                return `${idStr} (USB Hub)`;
            }
            if (n.serial) return `${n.serial}`;
            // Placeholder if vendor/product missing: show port number (supports nested "." and top-level "-")
            if (n.vendor || n.product) return `${n.vendor || ''}:${n.product || ''} (${idStr})`;
            let portNum = '';
            const dotParts = idStr.split('.');
            if (dotParts.length > 1) {
                portNum = dotParts[dotParts.length - 1];
            } else {
                const dashIdx = idStr.lastIndexOf('-');
                if (dashIdx !== -1) portNum = idStr.substring(dashIdx + 1);
            }
            if (portNum && /^\d+$/.test(portNum)) return `Port ${portNum} (empty)`;
            return idStr;
        }
    
        function computeBadge(n) {
            if (n.placeholder) return { className: 'badge-empty', text: '?' };
            if (n.modelGen === 5) return { className: 'badge-gen', text: '5' };
            if (n.modelGen === 4) return { className: 'badge-gen', text: '4' };
            // Connected device, model unknown yet (e.g., 2710 or earlier): show red '?'
            if (!n.isHub) return { className: 'badge-gen', text: '?' };
            return null;
        }

        // --- D3.js Interactive Graph Module ---
        const D3Graph = (() => {
            let svg, g, zoom, simulation, tooltip;
            let nodesData = [], linksData = [];
            let nodeElements, linkElements, labelElements;
            
            function generationText(n) {
                if (!n) return '';
                if (n.modelGen === 5) return '5';
                if (n.modelGen === 4) return '4';
                return '';
            }
            
            function labelForNode(n) {
                if (!n) return '';
                if (n.id === 'server') return 'Server';
                if (n.isHub) {
                    if (n.serial) return n.serial;
                    return 'Hub';
                }
                if (n.serial) return n.serial;
                if (n.vendor || n.product) return `${n.vendor||''}:${n.product||''}`.replace('::', ':');
                const idStr = String(n.id||'');
                let portNum = '';
                const dotParts = idStr.split('.');
                if (dotParts.length > 1) portNum = dotParts[dotParts.length - 1];
                else {
                    const dashIdx = idStr.lastIndexOf('-');
                    if (dashIdx !== -1) portNum = idStr.substring(dashIdx + 1);
                }
                if (portNum && /^\d+$/.test(portNum)) return `Port ${portNum}`;
                return 'Device';
            }
            
            function getNodeRadius(n) {
                if (n.id === 'server') return 40;
                if (n.isHub) return 30;
                return 28;
            }
            
            function getNodeClass(n) {
                if (n.id === 'server') return 'server';
                if (n.isHub) return 'hub';
                return 'device';
            }
            
            function tooltipText(n) {
                const parts = [];
                parts.push(`<strong>${labelForNode(n)}</strong>`);
                if (n.id && n.id !== 'server') parts.push(`ID: ${n.id}`);
                if (n.model) parts.push(`Model: ${n.model}`);
                if (n.state) parts.push(`State: ${n.state}`);
                if (n.ip) parts.push(`IP: ${n.ip}`);
                if (n.image) parts.push(`Image: ${n.image}`);
                return parts.join('<br/>');
            }

            
            function processNodes(rawNodes) {
                // Build canonical map and deduplicate nodes
                const canonicalByPort = buildCanonicalRootHubMap(rawNodes);
                const nodeMap = new Map();
                const links = [];
                
                rawNodes.forEach(n => {
                    const canonicalId = canonicalizeIdByRoot(String(n.id), canonicalByPort);
                    if (!nodeMap.has(canonicalId)) {
                        nodeMap.set(canonicalId, { ...n, id: canonicalId });
                    }
                });
                
                // Build links from parent relationships
                nodeMap.forEach(n => {
                    if (n.parentId) {
                        const canonicalParentId = canonicalizeIdByRoot(String(n.parentId), canonicalByPort);
                        const parent = nodeMap.get(canonicalParentId) || nodeMap.get('server');
                        if (parent) {
                            links.push({ source: parent.id, target: n.id });
                        }
                    }
                });
                
                return { nodes: Array.from(nodeMap.values()), links };
            }
            
            function init() {
                const container = document.querySelector('.mindmap-container');
                svg = d3.select('#d3-graph-svg');
                const width = container.clientWidth;
                const height = Math.max(container.clientHeight, 500);
                
                svg.attr('width', width).attr('height', height);
                
                // Create tooltip
                tooltip = d3.select(container)
                    .append('div')
                    .attr('class', 'd3-tooltip');
                
                // Add zoom controls
                const zoomControls = d3.select(container)
                    .append('div')
                    .attr('class', 'zoom-controls');
                
                zoomControls.append('button')
                    .attr('class', 'zoom-btn')
                    .html('+')
                    .on('click', () => svg.transition().call(zoom.scaleBy, 1.3));
                
                zoomControls.append('button')
                    .attr('class', 'zoom-btn')
                    .html('−')
                    .on('click', () => svg.transition().call(zoom.scaleBy, 0.7));
                
                zoomControls.append('button')
                    .attr('class', 'zoom-btn')
                    .html('⊙')
                    .on('click', () => svg.transition().call(zoom.transform, d3.zoomIdentity));
                
                // Setup zoom behavior
                zoom = d3.zoom()
                    .scaleExtent([0.3, 3])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                
                // Create main group for graph
                g = svg.append('g');
                
                // Setup force simulation
                simulation = d3.forceSimulation()
                    .force('link', d3.forceLink().id(d => d.id).distance(d => {
                        // Server to hubs: longer distance
                        if (d.source.id === 'server') return 180;
                        // Hub to devices: medium distance
                        if (d.source.isHub) return 120;
                        return 80;
                    }))
                    .force('charge', d3.forceManyBody().strength(-800))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(d => getNodeRadius(d) + 15))
                    .alphaDecay(0.02);
                
                return update;
            }
            
            function update(rawNodes) {
                const { nodes, links } = processNodes(rawNodes);
                
                nodesData = nodes;
                linksData = links;
                
                // Update links
                linkElements = g.selectAll('.d3-link')
                    .data(linksData, d => `${d.source.id}-${d.target.id}`);
                
                linkElements.exit().remove();
                
                const linkEnter = linkElements.enter()
                    .append('line')
                    .attr('class', 'd3-link');
                
                linkElements = linkEnter.merge(linkElements);
                
                // Update nodes
                const nodeGroups = g.selectAll('.d3-node-group')
                    .data(nodesData, d => d.id);
                
                nodeGroups.exit().remove();
                
                const nodeEnter = nodeGroups.enter()
                    .append('g')
                    .attr('class', 'd3-node-group')
                    .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));
                
                // Add circles
                nodeEnter.append('circle')
                    .attr('class', d => `d3-node-circle ${getNodeClass(d)}`)
                    .attr('r', d => getNodeRadius(d))
                    .on('click', (event, d) => {
                        // Navigate to device detail page (if not server)
                        if (d.id !== 'server' && !d.isHub && d.serial) {
                            window.location.href = `/device/${d.serial}`;
                        }
                        // Visual feedback
                        d3.selectAll('.d3-node-circle').classed('clicked', false);
                        d3.select(event.target).classed('clicked', true);
                    })
                    .on('mouseover', (event, d) => {
                        tooltip.html(tooltipText(d))
                            .classed('visible', true)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                        // Highlight connected links
                        linkElements.classed('highlighted', l => l.source.id === d.id || l.target.id === d.id);
                    })
                    .on('mouseout', () => {
                        tooltip.classed('visible', false);
                        linkElements.classed('highlighted', false);
                    });
                
                // Add generation watermark for devices
                nodeEnter.append('text')
                    .attr('class', 'd3-watermark')
                    .attr('font-size', d => d.id === 'server' ? '32' : '24')
                    .attr('dy', 4)
                    .text(d => generationText(d));
                
                // Add labels
                nodeEnter.append('text')
                    .attr('class', 'd3-node-label')
                    .attr('dy', d => getNodeRadius(d) + 14)
                    .text(d => labelForNode(d));
                
                // Add state text
                nodeEnter.append('text')
                    .attr('class', 'd3-node-state')
                    .attr('dy', d => -(getNodeRadius(d) + 6))
                    .text(d => d.state || '');
                
                const nodeGroupsMerged = nodeEnter.merge(nodeGroups);
                
                // Update existing nodes
                nodeGroupsMerged.select('.d3-node-label').text(d => labelForNode(d));
                nodeGroupsMerged.select('.d3-node-state').text(d => d.state || '');
                nodeGroupsMerged.select('.d3-watermark').text(d => generationText(d));
                
                // Update simulation
                simulation.nodes(nodesData).on('tick', ticked);
                simulation.force('link').links(linksData);
                simulation.alpha(0.3).restart();
                
                function ticked() {
                    linkElements
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                    
                    nodeGroupsMerged
                        .attr('transform', d => `translate(${d.x},${d.y})`);
                }
                
                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                
                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    // Uncomment to pin nodes after dragging:
                    // d.fx = null;
                    // d.fy = null;
                }
            }
            
            return { init };
        })();

        function metaFor(n) {
            const parts = [];
            if (!n.isHub && n.state) parts.push(`state: ${n.state}`);
            if (n.model) parts.push(`model: ${n.model}`);
            else if (n.image) parts.push(`image: ${n.image}`);
            if (n.ip) parts.push(`ip: ${n.ip}`);
            return parts.join('  •  ');
        }
    
        function ensureParentExists(parentId) {
            if (!parentId || parentId === 'null') parentId = 'server';
            if (elementsById.has(parentId)) return elementsById.get(parentId);
            // Create server root if needed
            if (parentId === 'server') {
                console.log('ensureParentExists: creating server root');
                const server = makeNodeElement({ id: 'server', isHub: true });
                topologyRoot.innerHTML = '';
                topologyRoot.appendChild(server);
                elementsById.set('server', server);
                return server;
            }
            // Fallback: attach to server until real parent appears
            console.warn('ensureParentExists: fallback to server for parent', parentId);
            return ensureParentExists('server');
        }
    
        function applyTopology(nodes) {
            try { console.log('applyTopology: received nodes', Array.isArray(nodes) ? nodes.length : nodes); } catch(e) {}
            const seen = new Set();
            const emittedIds = new Set(); // ids after canonicalization to avoid duplicates
            // Build per-root canonical mapping so companion hubs (e.g., buses 3/4) are coalesced
            const canonicalByPort = buildCanonicalRootHubMap(nodes);
            const nodeIdSet = new Set(nodes.map(n => String(n.id)));
            // Pre-create tier containers and at least 2 root-port groups per tier
            const portsByTier = { hs: new Set(), ss: new Set() };
            const hsBusSet = new Set();
            for (const n of nodes) {
                const id = String(n.id);
                const parentId = n.parentId ? String(n.parentId) : 'server';
                const port = parseRootPort(id);
                if (parentId === 'server' && port) {
                    const tier = busTierForId(id);
                    if (tier === 'ss') {
                        portsByTier.ss.add(port);
                    } else if (tier === 'hs') {
                        // Hide HS root groups that are fully aliased to SS companions
                        if (!canonicalByPort.has(port)) {
                            portsByTier.hs.add(port);
                            hsBusSet.add(parseBus(id));
                        }
                    }
                }
            }
            // Stable HS bus -> ordinal mapping (e.g., bus1 => 1, bus2 => 2)
            const hsBusOrder = Array.from(hsBusSet).filter(x => !isNaN(x)).sort((a,b)=>a-b);
            const hsBusToOrdinal = new Map();
            for (let i=0;i<hsBusOrder.length;i++) hsBusToOrdinal.set(hsBusOrder[i], i+1);
            // Only create HS groups for ports we actually intend to show
            const desiredMaxHs = Math.max(...Array.from(portsByTier.hs).map(p => parseInt(p, 10)).concat([0]));
            const desiredMaxSs = Math.max(2, ...Array.from(portsByTier.ss).map(p => parseInt(p, 10)).concat([0]));
            const hsTierEl = ensureRootTier('hs');
            for (let i = 1; i <= desiredMaxHs; i++) ensureRootPortGroupUnder(hsTierEl, i);
            const ssTierEl = ensureRootTier('ss');
            for (let i = 1; i <= desiredMaxSs; i++) ensureRootPortGroupUnder(ssTierEl, i);
            // Sort by parent depth and id to ensure stable parent-before-child ordering
            nodes.sort((a,b) => {
                const ad = String(a.parentId || 'server').split('.').length;
                const bd = String(b.parentId || 'server').split('.').length;
                if (ad !== bd) return ad - bd;
                return String(a.id).localeCompare(String(b.id));
            });
            for (const n of nodes) {
                const rawId = String(n.id);
                if (rawId === 'server') { seen.add('server'); continue; }
                // Canonicalize id by root-port; drop if it maps to an already-present id
                const canonicalId = canonicalizeIdByRoot(rawId, canonicalByPort);
                if (canonicalId !== rawId && (nodeIdSet.has(canonicalId) || emittedIds.has(canonicalId))) {
                    try { console.log('applyTopology: drop companion duplicate', rawId, '→', canonicalId); } catch(e) {}
                    continue;
                }
                const id = canonicalId; // use canonical id for rendering and grouping
                seen.add(id);
                let parentId = n.parentId ? String(n.parentId) : 'server';
                // Re-map parent to canonical so children of hidden companion hubs attach correctly
                parentId = canonicalizeIdByRoot(parentId, canonicalByPort);
                try { console.debug('applyTopology: node', { id, parentId, isHub: !!n.isHub, placeholder: !!n.placeholder, modelGen: n.modelGen }); } catch(e) {}
                // For direct root-port items, group under USB tier then "Root Port <n>"
                let parentEl;
                const maybeRootPort = parseRootPort(id);
                if (parentId === 'server' && maybeRootPort) {
                    const tier = busTierForId(id) || 'hs';
                    const tierEl = ensureRootTier(tier === 'ss' ? 'ss' : 'hs');
                    let groupIdx = maybeRootPort;
                    if (tier !== 'ss') {
                        const busNum = parseBus(id);
                        const ord = hsBusToOrdinal.get(busNum);
                        groupIdx = ord || (busNum === 2 ? 2 : 1); // fallback stable mapping
                    }
                    parentEl = ensureRootPortGroupUnder(tierEl, groupIdx);
                } else {
                    parentEl = ensureParentExists(parentId);
                }
                const childrenEl = parentEl.querySelector('.children');
                let el = elementsById.get(id);
                if (!el) {
                    el = makeNodeElement(n);
                    try { console.log('applyTopology: create element', id, 'under', parentId); } catch(e) {}
                    elementsById.set(id, el);
                    childrenEl.appendChild(el);
                } else {
                    // Minimal updates: only change when text differs
                    const title = el.querySelector('.title');
                    const newTitle = labelFor(n);
                    if (title.textContent !== newTitle) title.textContent = newTitle;
                    const meta = el.querySelector('.meta');
                    const newMeta = metaFor(n);
                    if (meta.textContent !== newMeta) meta.textContent = newMeta;
                    const desiredClass = 'node ' + (n.isHub ? 'hub' : 'device');
                    if (el.className.split(' ')[0] !== 'node' || (!el.classList.contains('hub') && n.isHub) || (!el.classList.contains('device') && !n.isHub)) {
                        el.className = desiredClass;
                    }
                    applyStateClass(el, n.state);
                    // Reparent only if needed
                    if (el.parentElement && el.parentElement !== childrenEl) {
                        try { console.log('applyTopology: reparent', id, 'to parent', parentId); } catch(e) {}
                        childrenEl.appendChild(el);
                    }
                }
                emittedIds.add(id);
            }
            // Do not remove unseen elements blindly. Only the backend should decide removals.
            // This avoids pruning placeholders or briefly missing nodes during enumeration.
            // If we add explicit removal messages in the future, handle them here.
            try { console.debug('applyTopology: pruning disabled; unseen nodes retained this tick'); } catch(e) {}
        }
    
        let isPageUnloading = false;
        
        function initWebSocket() {
            if (ws) try { ws.close(); } catch(e) {}
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const url = `${protocol}//${window.location.host}/ws/devices`;
            ws = new WebSocket(url);
            ws.onopen = () => { /* initial snapshot will be pushed by server */ };
            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    if (msg && msg.type === 'topology' && Array.isArray(msg.nodes)) {
                        try { console.log('ws: topology message nodes', msg.nodes.length, 'removed', Array.isArray(msg.removed) ? msg.removed.length : 0); } catch(e) {}
                        // Apply updates first
                        applyTopology(msg.nodes);
                        // Also update D3 interactive graph if active
                        if (window.__d3Apply) { try { window.__d3Apply(msg.nodes); } catch(e) { console.error('D3 update error:', e); } }
                        // Then process removals explicitly from backend
                        if (Array.isArray(msg.removed)) {
                            for (const id of msg.removed) {
                                if (id === 'server') continue;
                                const el = elementsById.get(String(id));
                                if (el) {
                                    try { console.log('ws: remove node from backend', id); } catch(e) {}
                                    el.remove();
                                    elementsById.delete(String(id));
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('Invalid topology message', e);
                }
            };
            ws.onclose = () => {
                // Only attempt reconnect if page is not being unloaded
                if (!isPageUnloading) {
                    setTimeout(initWebSocket, 1000);
                }
            };
            ws.onerror = () => {
                try { ws.close(); } catch(e) {}
            };
        }
        
        // Cleanup when navigating away
        window.addEventListener('beforeunload', () => {
            console.log('Page unloading - cleaning up WebSocket');
            isPageUnloading = true;
            if (ws) {
                try { ws.close(); } catch(e) {}
                ws = null;
            }
        });
        
        // Also cleanup on page hide (covers more navigation scenarios)
        window.addEventListener('pagehide', () => {
            console.log('Page hidden - cleaning up WebSocket');
            isPageUnloading = true;
            if (ws) {
                try { ws.close(); } catch(e) {}
                ws = null;
            }
        });
    </script>
</head>
<body>
    <%view navbar %>
    
    <h1>Devices</h1>
    <div class="view-tabs">
        <button id="tab-rel" class="view-tab active">Relational</button>
        <button id="tab-topo" class="view-tab">Detail</button>
    </div>
    <div id="rel-view" class="view-container active">
        <div class="mindmap-container"><svg id="d3-graph-svg"></svg></div>
    </div>
    <div id="topo-view" class="view-container">
        <div class="topology-container">
            <div id="topology-root"></div>
        </div>
    </div>
    
    <script>
        const topologyRoot = document.getElementById('topology-root');
        // Initialize with a server root to minimize layout shifts
        applyTopology([{ id: 'server', isHub: true }]);
        // Initialize D3 interactive graph
        window.__d3Apply = D3Graph.init();
        // Tabs
        const tabRel = document.getElementById('tab-rel');
        const tabTopo = document.getElementById('tab-topo');
        const relView = document.getElementById('rel-view');
        const topoView = document.getElementById('topo-view');
        function setActive(which){
            if (which==='rel'){ tabRel.classList.add('active'); tabTopo.classList.remove('active'); relView.classList.add('active'); topoView.classList.remove('active'); }
            else { tabTopo.classList.add('active'); tabRel.classList.remove('active'); topoView.classList.add('active'); relView.classList.remove('active'); }
        }
        tabRel.addEventListener('click', ()=>setActive('rel'));
        tabTopo.addEventListener('click', ()=>setActive('topo'));
        initWebSocket();
    </script>
</body>
</html> 