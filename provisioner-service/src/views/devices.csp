<!DOCTYPE html>
<html>
<head>
    <title>USB Topology</title>
    <%view stylesheet %>
    <style>
        .topology-container { padding: 10px; }
        .node { border: 1px solid #ccc; border-radius: 6px; padding: 8px 10px; margin: 6px; background: #fafafa; display: inline-block; min-width: 160px; }
        .hub { background: #eef6ff; border-color: #9ec9ff; }
        .device { background: #f7fff0; border-color: #bde6a1; }
        .node .title { font-weight: bold; margin-bottom: 4px; }
        .children { margin-left: 24px; border-left: 2px dashed #ddd; padding-left: 12px; }
        .state-provisioning { box-shadow: 0 0 0 2px #ffd54f inset; }
        .state-success { box-shadow: 0 0 0 2px #4caf50 inset; }
        .state-error { box-shadow: 0 0 0 2px #f44336 inset; }
        .meta { color: #555; font-size: 12px; }
    </style>
    <script>
        let ws = null;
        const elementsById = new Map();
    
        function makeNodeElement(node) {
            const el = document.createElement('div');
            el.className = 'node ' + (node.isHub ? 'hub' : 'device');
            el.dataset.id = node.id;
            const title = document.createElement('div');
            title.className = 'title';
            title.textContent = labelFor(node);
            const meta = document.createElement('div');
            meta.className = 'meta';
            meta.textContent = metaFor(node);
            const children = document.createElement('div');
            children.className = 'children';
            el.appendChild(title);
            el.appendChild(meta);
            el.appendChild(children);
            applyStateClass(el, node.state);
            return el;
        }
    
        function applyStateClass(el, state) {
            el.classList.remove('state-provisioning', 'state-success', 'state-error');
            if (!state) return;
            const s = state.toLowerCase();
            if (s.includes('provision') || s.includes('pending')) el.classList.add('state-provisioning');
            else if (s.includes('success') || s.includes('complete')) el.classList.add('state-success');
            else if (s.includes('error') || s.includes('fail')) el.classList.add('state-error');
        }
    
        function labelFor(n) {
            if (n.id === 'server') return 'Provisioning Server';
            if (n.serial) return `${n.serial}`;
            if (n.vendor || n.product) return `${n.vendor || ''}:${n.product || ''} (${n.id})`;
            return n.id;
        }
    
        function metaFor(n) {
            const parts = [];
            if (n.state) parts.push(`state: ${n.state}`);
            if (n.image) parts.push(`image: ${n.image}`);
            if (n.ip) parts.push(`ip: ${n.ip}`);
            return parts.join('  â€¢  ');
        }
    
        function ensureParentExists(parentId) {
            if (!parentId || parentId === 'null') parentId = 'server';
            if (elementsById.has(parentId)) return elementsById.get(parentId);
            // Create server root if needed
            if (parentId === 'server') {
                const server = makeNodeElement({ id: 'server', isHub: true });
                topologyRoot.innerHTML = '';
                topologyRoot.appendChild(server);
                elementsById.set('server', server);
                return server;
            }
            // Fallback: attach to server until real parent appears
            return ensureParentExists('server');
        }
    
        function applyTopology(nodes) {
            const seen = new Set();
            // Sort by depth so parents tend to be created before children
            nodes.sort((a,b) => (String(a.id).split('.').length) - (String(b.id).split('.').length));
            for (const n of nodes) {
                const id = String(n.id);
                seen.add(id);
                const parentId = n.parentId ? String(n.parentId) : 'server';
                const parentEl = ensureParentExists(parentId);
                const childrenEl = parentEl.querySelector(':scope > .children');
                let el = elementsById.get(id);
                if (!el) {
                    el = makeNodeElement(n);
                    elementsById.set(id, el);
                    childrenEl.appendChild(el);
                } else {
                    // Minimal updates: only change when text differs
                    const title = el.querySelector(':scope > .title');
                    const newTitle = labelFor(n);
                    if (title.textContent !== newTitle) title.textContent = newTitle;
                    const meta = el.querySelector(':scope > .meta');
                    const newMeta = metaFor(n);
                    if (meta.textContent !== newMeta) meta.textContent = newMeta;
                    const desiredClass = 'node ' + (n.isHub ? 'hub' : 'device');
                    if (el.className.split(' ')[0] !== 'node' || (!el.classList.contains('hub') && n.isHub) || (!el.classList.contains('device') && !n.isHub)) {
                        el.className = desiredClass;
                    }
                    applyStateClass(el, n.state);
                    // Reparent only if needed
                    if (el.parentElement && el.parentElement !== childrenEl) {
                        childrenEl.appendChild(el);
                    }
                }
            }
            // Remove stale elements
            for (const [id, el] of Array.from(elementsById.entries())) {
                if (!seen.has(id) && id !== 'server') {
                    el.remove();
                    elementsById.delete(id);
                }
            }
        }
    
        function initWebSocket() {
            if (ws) try { ws.close(); } catch(e) {}
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const url = `${protocol}//${window.location.host}/ws/devices`;
            ws = new WebSocket(url);
            ws.onopen = () => { /* initial snapshot will be pushed by server */ };
            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    if (msg && msg.type === 'topology' && Array.isArray(msg.nodes)) {
                        applyTopology(msg.nodes);
                    }
                } catch (e) {
                    console.error('Invalid topology message', e);
                }
            };
            ws.onclose = () => {
                setTimeout(initWebSocket, 1000);
            };
            ws.onerror = () => {
                try { ws.close(); } catch(e) {}
            };
        }
    </script>
</head>
<body>
    <%view navbar %>
    
    <h1>USB Topology</h1>
    
    <div class="topology-container">
        <div id="topology-root"></div>
    </div>
    
    <script>
        const topologyRoot = document.getElementById('topology-root');
        // Initialize with a server root to minimize layout shifts
        applyTopology([{ id: 'server', isHub: true }]);
        initWebSocket();
    </script>
</body>
</html> 